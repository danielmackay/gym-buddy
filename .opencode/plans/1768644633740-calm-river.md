# CORS Configuration Plan

## Problem Statement
The frontend application (Next.js running on `http://localhost:3000` in dev, and production domain in prod) cannot make API calls to the backend (`https://localhost:7255` in dev, `https://api.gymbuddy.com` in prod) due to missing CORS configuration. The backend currently has **no CORS middleware or policies configured**, causing browsers to block cross-origin requests in both development and production environments.

## Current State
- **Backend CORS**: ❌ None configured (no `AddCors()` or `UseCors()` in Program.cs)
- **Frontend Dev URL**: `http://localhost:3000`
- **Backend Dev URL**: `https://localhost:7255`
- **Frontend Prod URL**: `https://gymbuddy.com` (assumed)
- **Backend Prod URL**: `https://api.gymbuddy.com`
- **Environment Variables**: Properly configured in `.env.local` and `.env.production`

## Solution Options

### Option A: Backend CORS Middleware (Recommended)
**Description**: Add CORS middleware to the .NET backend to allow requests from specific origins.

**Pros**:
- Standard, industry-accepted approach
- Works for all deployment scenarios
- Explicit control over allowed origins, methods, and headers
- Easy to configure different policies for dev vs prod
- No additional infrastructure required
- Supports credentials (cookies, auth headers)

**Cons**:
- Requires backend code changes
- Need to maintain list of allowed origins

**Implementation**:
- Add CORS services and middleware in `src/api/src/WebApi/Program.cs`
- Configure separate policies for development (localhost) and production (specific domains)
- Use environment-based configuration for allowed origins

---

### Option B: Next.js API Rewrites/Proxy
**Description**: Configure Next.js to proxy API requests through the Next.js server, eliminating CORS since requests appear same-origin.

**Pros**:
- No CORS headers needed
- Frontend makes requests to same origin
- Can work around restrictive CORS policies
- Good for development environment

**Cons**:
- **Does NOT solve production CORS** (Next.js server-side proxying only works in dev server, not in production static exports or client-side fetches)
- Adds latency (extra hop through Next.js server)
- More complex deployment (Next.js server must be running)
- Doesn't work with PWA offline features (service workers make direct requests)
- Hides the real API structure from frontend developers

---

### Option C: Reverse Proxy (Nginx/Azure Front Door)
**Description**: Deploy a reverse proxy in front of both frontend and backend, serving them from the same origin.

**Pros**:
- No CORS issues (truly same-origin)
- Single domain for users (`https://app.com` for both UI and API)
- Can handle SSL termination, load balancing, caching
- Production-grade solution

**Cons**:
- **Overkill for localhost development**
- Requires infrastructure setup and maintenance
- More complex deployment
- Higher operational complexity
- Still need Option A for local development

---

### Option D: Browser Extensions (Development Only)
**Description**: Use browser extensions like "CORS Unblock" or disable CORS in browser flags.

**Pros**:
- Zero code changes
- Quick workaround for local testing

**Cons**:
- **Only works in development**
- **Does NOT solve production CORS** ❌
- Security risk if left enabled
- Not a real solution (hides the problem)
- Doesn't work for other team members without setup

---

### Option E: Combine Backend CORS + Production Reverse Proxy
**Description**: Use Option A (backend CORS) for development and Option C (reverse proxy) for production.

**Pros**:
- Best of both worlds
- Professional production setup
- Simple development experience

**Cons**:
- Most complex to set up
- Higher infrastructure costs
- Two different configurations to maintain

---

## Comparison Table

| Option | Dev Support | Prod Support | PWA Compatible | Complexity | Infrastructure | Recommended |
|--------|-------------|--------------|----------------|------------|----------------|-------------|
| **A. Backend CORS** | ✅ | ✅ | ✅ | Low | None | ⭐ **YES** |
| **B. Next.js Proxy** | ⚠️ | ❌ | ❌ | Medium | None | ❌ No |
| **C. Reverse Proxy** | ❌ | ✅ | ✅ | High | Required | ❌ No |
| **D. Browser Ext** | ✅ | ❌ | ❌ | None | None | ❌ No |
| **E. Combined** | ✅ | ✅ | ✅ | High | Required | ⚠️ Maybe |

---

## Final Recommendation: **Option A - Backend CORS Middleware**

### Why Option A?
1. **Solves both dev and production** - Single solution works everywhere
2. **PWA Compatible** - Service workers can make direct API calls (critical for offline support)
3. **Standard Practice** - Industry-standard approach used by all modern web APIs
4. **Simple** - No extra infrastructure, just code configuration
5. **Flexible** - Easy to adjust policies per environment
6. **Auth-Ready** - Works with future Auth0 integration (supports credentials)
7. **Current Stack Aligned** - Matches your .NET/Next.js/Aspire setup

### When to Consider Option E (A + C)?
Only if you have specific production requirements like:
- Need single domain for branding (`app.gymbuddy.com` instead of `api.gymbuddy.com`)
- Advanced caching/CDN requirements
- Enterprise security policies requiring same-origin
- Large scale with load balancing needs

**For your current stage (MVP/development)**: Option A is sufficient and recommended.

---

## Implementation Plan - Option A (Backend CORS)

### Files to Modify
1. `src/api/src/WebApi/Program.cs` - Add CORS middleware
2. `src/api/src/WebApi/appsettings.Development.json` - Add dev allowed origins
3. `src/api/src/WebApi/appsettings.json` - Add prod allowed origins config
4. Optional: Create `src/api/src/WebApi/Host/Extensions/CorsExt.cs` - Encapsulate CORS setup

### Step 1: Add CORS Configuration
**File**: `src/api/src/WebApi/Program.cs`

Add CORS services before `builder.Build()`:
```csharp
// After line 21: builder.AddFastEndpoints();

// Add CORS services
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowFrontend", policy =>
    {
        var allowedOrigins = builder.Configuration
            .GetSection("CorsSettings:AllowedOrigins")
            .Get<string[]>() ?? new[] { "http://localhost:3000" };

        policy.WithOrigins(allowedOrigins)
              .AllowAnyMethod()
              .AllowAnyHeader()
              .AllowCredentials(); // For future Auth0 integration
    });
});
```

Add CORS middleware after `app.UseHttpsRedirection()`:
```csharp
// After line 33: app.UseHttpsRedirection();

// Use CORS before routing/endpoints
app.UseCors("AllowFrontend");
```

### Step 2: Configure Allowed Origins - Development
**File**: `src/api/src/WebApi/appsettings.Development.json`

Add CORS settings:
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "CorsSettings": {
    "AllowedOrigins": [
      "http://localhost:3000",
      "https://localhost:3000"
    ]
  }
}
```

### Step 3: Configure Allowed Origins - Production
**File**: `src/api/src/WebApi/appsettings.json`

Add CORS settings:
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "CorsSettings": {
    "AllowedOrigins": [
      "https://gymbuddy.com",
      "https://www.gymbuddy.com"
    ]
  }
}
```

### Step 4: (Optional) Create CORS Extension Method
**File**: `src/api/src/WebApi/Host/Extensions/CorsExt.cs` (NEW)

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace WebApi.Host.Extensions;

public static class CorsExt
{
    public static IServiceCollection AddCorsConfiguration(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        services.AddCors(options =>
        {
            options.AddPolicy("AllowFrontend", policy =>
            {
                var allowedOrigins = configuration
                    .GetSection("CorsSettings:AllowedOrigins")
                    .Get<string[]>() ?? new[] { "http://localhost:3000" };

                policy.WithOrigins(allowedOrigins)
                      .AllowAnyMethod()
                      .AllowAnyHeader()
                      .AllowCredentials();
            });
        });

        return services;
    }

    public static IApplicationBuilder UseCorsConfiguration(this IApplicationBuilder app)
    {
        app.UseCors("AllowFrontend");
        return app;
    }
}
```

Then in `Program.cs`:
```csharp
// Services
builder.AddCorsConfiguration(builder.Configuration);

// Middleware (after UseHttpsRedirection)
app.UseCorsConfiguration();
```

---

## Verification Steps

### 1. Development Testing (localhost)
```bash
# Terminal 1: Start full stack
aspire run

# Wait for services to start, then test in browser
# Open DevTools > Network tab
# Navigate to http://localhost:3000
# Verify API calls succeed without CORS errors
```

**Expected Result**:
- ✅ No CORS errors in browser console
- ✅ API requests show `Access-Control-Allow-Origin: http://localhost:3000` header in response
- ✅ User list, trainer creation, etc. all work

### 2. Verify Response Headers
Open browser DevTools > Network tab:
- Click any API request (e.g., `GET /api/users`)
- Check Response Headers for:
  ```
  Access-Control-Allow-Origin: http://localhost:3000
  Access-Control-Allow-Credentials: true
  Access-Control-Allow-Methods: *
  Access-Control-Allow-Headers: *
  ```

### 3. Test Preflight Requests (OPTIONS)
Some requests trigger CORS preflight (OPTIONS):
- Open DevTools > Network tab
- Filter by "Fetch/XHR"
- Look for OPTIONS requests before POST/PUT/DELETE
- Verify OPTIONS requests return 204 No Content with CORS headers

### 4. Production Testing (when deployed)
```bash
# Update frontend .env.production with actual domain
NEXT_PUBLIC_API_URL=https://api.gymbuddy.com/api

# Update backend appsettings.json CorsSettings:AllowedOrigins
# with production frontend domain

# Test in production environment
# Verify CORS headers match production frontend domain
```

### 5. Integration Test Verification
Existing integration tests should continue to pass:
```bash
cd src/api
dotnet test
```

**Note**: CORS is a browser security feature, so integration tests (using HttpClient) won't be affected.

---

## Configuration Guidelines

### Security Best Practices
1. **Never use `AllowAnyOrigin()` with `AllowCredentials()`** - Browser will reject
2. **Never use `AllowAnyOrigin()` in production** - Security risk
3. **Use specific origins** - List exact domains in configuration
4. **Keep origins in config** - Don't hardcode in Program.cs
5. **Use HTTPS in production** - Only allow HTTPS origins

### Environment-Specific Origins
| Environment | Frontend URL | Backend URL | CORS Origin |
|-------------|--------------|-------------|-------------|
| **Local Dev** | `http://localhost:3000` | `https://localhost:7255` | `http://localhost:3000` |
| **Staging** | `https://staging.gymbuddy.com` | `https://api-staging.gymbuddy.com` | `https://staging.gymbuddy.com` |
| **Production** | `https://gymbuddy.com` | `https://api.gymbuddy.com` | `https://gymbuddy.com` |

### Future Auth0 Integration
The configuration is already Auth0-ready with `.AllowCredentials()`, which allows:
- Cookies
- Authorization headers
- Client certificates

When implementing Auth0:
1. Keep `.AllowCredentials()` ✅
2. Add JWT validation middleware
3. No CORS configuration changes needed

---

## Alternative: If Option A Doesn't Meet Future Needs

If you later need Option E (reverse proxy in production):
- Keep Option A for development
- Deploy Azure Front Door / Nginx in production
- Route `https://app.gymbuddy.com` → frontend
- Route `https://app.gymbuddy.com/api/*` → backend
- Result: Same-origin in production, CORS in dev

**Complexity**: High
**Timeline**: Later phase (post-MVP)
**Decision**: Revisit when scaling

---

## Summary
- **Recommended**: Option A - Backend CORS Middleware
- **Implementation**: 4 steps (Program.cs + appsettings files)
- **Time Estimate**: 15-30 minutes
- **Risk**: Low (standard pattern, easily reversible)
- **Works for**: Development + Production + PWA
